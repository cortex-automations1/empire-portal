# Architecture

**Analysis Date:** February 2, 2026  
**Codebase:** Empire Portal (Turborepo Monorepo)

---

## Pattern Overview

**Overall:** Three-tier monorepo architecture with clear separation of concerns

**Key Characteristics:**
- Turborepo monorepo with pnpm workspaces
- Frontend (Next.js App Router) + Backend (Express API) + Workers (Cron jobs)
- Shared packages for types, utilities, database access
- PostgreSQL database with Prisma ORM
- External integration: Mercury Bank API
- Stateless request handling (REST API)
- Time-based job execution (cron workers)

**Architecture Pattern:** Layered + Service-Oriented

---

## System Components

### 1. Frontend (apps/web)
**Technology:** Next.js 15 with App Router, React Server Components, Tailwind CSS

**Purpose:** User-facing dashboard for financial data visualization

**Key Features:**
- Server-side rendering for fast initial load
- Client-side interactivity for charts and filters
- Direct database access from Server Components (authorized only)
- Client components for interactive UI

**Entry Point:** `apps/web/app/layout.tsx` (root layout)

---

### 2. Backend API (apps/api)
**Technology:** Express + TypeScript

**Purpose:** Business logic, external API integration, data aggregation

**Key Features:**
- RESTful API endpoints
- Mercury Bank API integration
- Data sync orchestration
- Rate limiting and authentication middleware

**Entry Point:** `apps/api/src/index.ts` (Express server)

---

### 3. Workers (apps/workers)
**Technology:** Node.js scheduled jobs

**Purpose:** Automated background tasks (sync, reports, alerts)

**Key Features:**
- Daily Mercury data sync
- Automated report generation
- Alert monitoring and delivery

**Entry Point:** Individual job files in `apps/workers/src/jobs/`

---

### 4. Shared Packages

**packages/shared:**
- TypeScript types (Entity, Account, Balance, Transaction, etc.)
- Utility functions (formatCurrency, formatDate, custom errors)
- Constants (entity names, types, API endpoints)

**packages/database:**
- Prisma schema (10 tables)
- Prisma client singleton
- Database utilities

**packages/config:**
- Shared TypeScript configs (base, nextjs, node)
- Shared ESLint config
- Shared Tailwind config

---

## Architectural Layers

### Layer 1: Presentation (Frontend)

**Location:** `apps/web/`

**Responsibilities:**
- Render UI components
- Handle user interactions
- Display financial data (charts, tables, cards)
- Client-side state management
- Form validation (client-side)

**Contains:**
- React Server Components (`app/**/page.tsx`)
- Client Components (`components/**/*.tsx`)
- Custom hooks (`hooks/**/*.ts`)
- UI components (shadcn/ui in `components/ui/`)

**Depends On:**
- Backend API (fetch from `/api/*` routes)
- Shared types (`@empire/shared`)
- Database (Server Components only, via Prisma)

**Used By:** End users (web browsers)

---

### Layer 2: API / Service (Backend)

**Location:** `apps/api/src/`

**Responsibilities:**
- Expose REST API endpoints
- Orchestrate business logic
- Integrate with external APIs (Mercury Bank)
- Aggregate and transform data
- Enforce authorization and rate limiting
- Log all operations

**Contains:**
- Route handlers (`routes/*.ts`)
- Service layer (`services/*.ts`)
- Middleware (`middleware/*.ts`)
- Utilities (`utils/*.ts`)

**Depends On:**
- Database (`@empire/database`)
- Shared types (`@empire/shared`)
- External APIs (Mercury Bank)

**Used By:**
- Frontend (Next.js app)
- Workers (job scripts)

---

### Layer 3: Data Access (Database)

**Location:** `packages/database/`

**Responsibilities:**
- Define database schema (Prisma)
- Provide type-safe query interface
- Handle migrations
- Manage connections

**Contains:**
- Prisma schema (`prisma/schema.prisma`)
- Prisma client wrapper (`src/client.ts`)
- Type definitions (auto-generated by Prisma)

**Depends On:**
- PostgreSQL database (Railway)

**Used By:**
- Backend API
- Frontend Server Components
- Workers

---

### Layer 4: External Services

**Mercury Bank API:**
- REST API at `https://api.mercury.com/api/v1/`
- Authentication: Bearer token per entity
- Rate limit: 100 req/min per token
- Endpoints: `/accounts`, `/transactions`

**Vercel (Frontend Hosting):**
- Deploys Next.js app
- Edge functions for server components
- Environment variables

**Railway (Backend + Database):**
- PostgreSQL database
- Express API service
- Worker service (cron jobs)
- Environment variables

**Cloudflare (DNS):**
- Manages `portal.keystonebg.us` domain
- SSL/TLS termination

---

## Data Flow Patterns

### Pattern 1: Page Load (Server-Side Rendered)

**Flow:** User → Next.js Server Component → Database → Render → Browser

```
1. User navigates to /dashboard
2. Next.js server executes app/dashboard/page.tsx
3. Server Component fetches data:
   - Import prisma from @empire/database
   - Query: prisma.entity.findMany({ include: { accounts: true } })
4. Server renders React component with data
5. HTML + JSON sent to browser
6. Client hydrates (minimal JavaScript)
```

**Advantages:**
- Fast initial load (no API round-trip)
- SEO-friendly
- Secure (no client-side API keys)

**When to Use:**
- Dashboard pages
- Entity detail pages
- Any page that needs fast initial render

---

### Pattern 2: Client-Side Data Fetching

**Flow:** User → Client Component → API Endpoint → Service → Database → Response

```
1. User clicks "Refresh Balances" button
2. Client component makes fetch request:
   fetch('/api/mercury/balances')
3. Next.js API route handler (app/api/mercury/balances/route.ts)
4. Route handler calls service:
   MercuryService.syncAllEntities()
5. Service fetches from Mercury API
6. Service stores in database (Prisma)
7. Service returns data
8. API responds: { success: true, data: [...] }
9. Client component updates state
10. UI re-renders with new data
```

**When to Use:**
- User-triggered actions (refresh, filter, search)
- Real-time updates (polling)
- Form submissions

---

### Pattern 3: Background Job (Cron Worker)

**Flow:** Cron Schedule → Worker → Service → Mercury API → Database

```
1. Railway triggers job at 7:00 AM CST (cron: 0 7 * * *)
2. Worker script executes: src/jobs/daily-sync.ts
3. Worker calls service:
   await MercuryService.syncAllEntities()
4. Service loops through 6 entities:
   for (const entity of entities) {
     const accounts = await mercury.getAccounts(entity.apiKey)
     for (const account of accounts) {
       const balance = await mercury.getBalance(entity.apiKey, account.id)
       await prisma.balance.create({ /* snapshot */ })
     }
   }
5. Worker logs results:
   console.log({ synced: 30, errors: 0, duration: 45000 })
6. If errors, send WhatsApp alert via OpenClaw
```

**When to Use:**
- Daily Mercury sync
- Weekly/monthly reports
- Alert monitoring (hourly)

---

## Key Abstractions

### Service Pattern

**Purpose:** Encapsulate business logic and external integrations

**Examples:**
- `MercuryService` (apps/api/src/services/mercury-service.ts)
  - `getAccounts(apiKey: string): Promise<Account[]>`
  - `getBalance(apiKey: string, accountId: string): Promise<number>`
  - `getTransactions(apiKey: string, accountId: string, filters): Promise<Transaction[]>`
  - `syncEntity(entityId: string): Promise<void>`
- `ReportService` (apps/api/src/services/report-service.ts)
  - `generateDailyBriefing(): Promise<string>`
  - `generateWeeklyReport(entityId: string): Promise<PDF>`
- `AlertService` (apps/api/src/services/alert-service.ts)
  - `checkLowBalances(): Promise<Alert[]>`
  - `checkGoalProgress(): Promise<Alert[]>`

**Pattern:**
- Export named functions (not class instances)
- Each function is stateless (no shared mutable state)
- Async by default (all I/O operations)
- Throw typed errors on failure

---

### Repository Pattern (Prisma)

**Purpose:** Abstract database queries behind type-safe interface

**Examples:**
- Prisma Client methods:
  ```typescript
  await prisma.entity.findMany({ include: { accounts: true } })
  await prisma.balance.create({ data: { /* ... */ } })
  await prisma.transaction.findMany({ where: { entityId: 'myte' }, orderBy: { date: 'desc' } })
  ```

**Pattern:**
- Use Prisma Client directly (no custom repository classes)
- Leverage Prisma's type generation
- Use `include` for relations, `select` for specific fields
- Use transactions for multi-step operations: `prisma.$transaction([...])`

---

### API Response Pattern

**Purpose:** Consistent API response format

**Type Definition:** `packages/shared/src/types/api.ts`
```typescript
export type ApiResponse<T> = {
  success: true;
  data: T;
} | {
  success: false;
  error: {
    message: string;
    code?: string;
    details?: unknown;
  };
};
```

**Usage:**
```typescript
// Success
return Response.json({ success: true, data: balances });

// Error
return Response.json(
  { success: false, error: { message: 'Invalid API key', code: 'AUTH_FAILED' } },
  { status: 401 }
);
```

---

## Entry Points

### 1. Web Application

**Location:** `apps/web/app/layout.tsx`

**Triggers:** User navigates to `https://portal.keystonebg.us`

**Responsibilities:**
- Set up root layout (HTML structure, fonts, global CSS)
- Initialize authentication context (Clerk)
- Render child pages

**Flow:**
```
layout.tsx (root)
  ├── app/page.tsx (dashboard)
  ├── app/financial/page.tsx
  ├── app/businesses/[entity]/page.tsx
  └── app/api/*/route.ts (API routes)
```

---

### 2. API Server

**Location:** `apps/api/src/index.ts`

**Triggers:** HTTP request to API endpoint

**Responsibilities:**
- Start Express server (port 3001)
- Register middleware (CORS, rate limit, auth, error handler)
- Register routes (`/api/mercury/*`, `/api/reports/*`, `/api/alerts/*`)
- Connect to database (Prisma)
- Log server startup

**Flow:**
```
index.ts
  ├── middleware/cors.ts
  ├── middleware/rate-limit.ts
  ├── middleware/auth.ts (future)
  ├── routes/mercury.routes.ts
  ├── routes/reports.routes.ts
  └── middleware/error.ts
```

---

### 3. Cron Workers

**Location:** `apps/workers/src/jobs/daily-sync.ts`

**Triggers:** Railway cron schedule (7:00 AM CST daily)

**Responsibilities:**
- Execute scheduled job
- Call service layer
- Log results
- Alert on failures

**Flow:**
```
Railway Cron → daily-sync.ts
  ├── MercuryService.syncAllEntities()
  ├── Logger.info({ synced, errors })
  └── AlertService.notifyErrors() (if errors)
```

---

## Cross-Cutting Concerns

### Authentication

**Strategy:** Clerk (Phase 5)

**Implementation:**
- Clerk middleware in Next.js: `middleware.ts`
- Protect API routes with Clerk verification
- Store user ID in audit log

**Not Yet Implemented:**
- Currently no auth (local dev only)
- Phase 5 will add Clerk

---

### Authorization

**Strategy:** Role-based access control (RBAC)

**Roles:**
- **Owner** (David): Full access to everything
- **Admin** (Kami): Read + limited write (future)
- **Viewer** (Accountant): Read-only (future)
- **Auditor** (CPA): Entity-specific read (future)

**Implementation:**
- Store role in User table (Clerk metadata)
- Middleware checks role before allowing operation
- UI hides actions user can't perform

---

### Logging

**Strategy:** Structured JSON logs to stdout (Railway/Vercel)

**What to Log:**
- API requests (method, path, status, duration)
- External API calls (Mercury requests, responses, errors)
- State changes (balance updates, sync completion)
- Errors (with full context and stack trace)
- Security events (login, failed auth)

**What NOT to Log:**
- API keys or secrets
- Full account numbers (mask: `****1234`)
- Passwords

---

### Validation

**Strategy:** Zod schemas at API boundaries

**Implementation:**
```typescript
import { z } from 'zod';

const BalanceFilterSchema = z.object({
  entityId: z.string().optional(),
  startDate: z.string().datetime().optional(),
  endDate: z.string().datetime().optional(),
});

export async function GET(request: Request) {
  const params = BalanceFilterSchema.parse(await request.json());
  // ...
}
```

**Validation Points:**
- API route parameters (query, body)
- Environment variables (on startup)
- Mercury API responses (ensure expected shape)

---

### Error Handling

**Strategy:** Throw at source, catch at boundary

**Custom Errors:** `packages/shared/src/utils/errors.ts`
- `MercuryAPIError` - Mercury API failures
- `ValidationError` - Invalid input
- `AuthenticationError` - Auth failures (future)
- `DatabaseError` - Prisma errors

**Middleware:** `apps/api/src/middleware/error.ts`
```typescript
function errorHandler(err, req, res, next) {
  if (err instanceof MercuryAPIError) {
    return res.status(err.statusCode).json({
      success: false,
      error: { message: err.message, code: 'MERCURY_API_ERROR' }
    });
  }
  // ... handle other errors
}
```

---

### Caching

**Strategy:** Redis (planned) for frequently accessed data

**Cache Keys:**
- `balance:{entity}:{accountId}` - Balance data (5 min TTL)
- `transactions:{accountId}:{startDate}:{endDate}` - Transaction history (15 min TTL)

**Implementation (Future):**
```typescript
const cached = await redis.get(`balance:${entity}:${accountId}`);
if (cached) return JSON.parse(cached);

const balance = await fetchFromMercury();
await redis.set(`balance:${entity}:${accountId}`, JSON.stringify(balance), 'EX', 300);
return balance;
```

**Current:**
- No caching yet (Phase 2 focus on correctness first)
- Add Redis in Phase 4 (Automation) if needed

---

## Security Architecture

### Secrets Management

**Storage:** Environment variables (never in code)

**Access:**
- Railway environment variables (backend, workers)
- Vercel environment variables (frontend, API routes)
- Local: `.env.local` (gitignored)

**Secrets:**
- `MERCURY_*_API_KEY` (6 entity API keys)
- `DATABASE_URL` (PostgreSQL connection string)
- `CLERK_SECRET_KEY` (future - authentication)
- `CLOUDFLARE_API_TOKEN` (DNS management)

---

### API Security

**Rate Limiting:**
- 100 requests per 15 minutes per IP
- Express middleware: `express-rate-limit`

**CORS:**
- Allow only `portal.keystonebg.us` origin
- Block all other domains

**Input Validation:**
- Zod schemas on all inputs
- Sanitize user-provided data

---

### Data Protection

**In Transit:**
- HTTPS enforced (Vercel, Railway)
- TLS 1.3 minimum

**At Rest:**
- Database encryption (Railway provides)
- No field-level encryption (not needed for MVP)

---

## Deployment Architecture

```
┌─────────────────────────────────────────────────────────┐
│                         Cloudflare                       │
│                 (DNS, SSL, portal.keystonebg.us)        │
└─────────────────┬───────────────────────────────────────┘
                  │
         ┌────────┴────────┐
         │                 │
    ┌────▼─────┐     ┌─────▼──────┐
    │  Vercel  │     │  Railway   │
    │ (Frontend)│    │ (Backend)  │
    │ Next.js  │     │ Express    │
    │          │     │ Workers    │
    │          │     │ PostgreSQL │
    └────┬─────┘     └─────┬──────┘
         │                 │
         └────────┬────────┘
                  │
          ┌───────▼────────┐
          │  Mercury API   │
          │ (External)     │
          └────────────────┘
```

**Hosting:**
- **Frontend:** Vercel (Next.js) - Edge deployment, auto-scaling
- **Backend:** Railway (Express) - Container deployment
- **Database:** Railway (PostgreSQL) - Managed database
- **Workers:** Railway (Cron jobs) - Scheduled execution

---

## Performance Considerations

### Frontend
- Server Components for fast initial load (no JS for static content)
- Client Components only for interactivity
- Lazy load charts (React.lazy + Suspense)
- Image optimization (Next.js Image component)

### Backend
- Database indexes on frequently queried fields (entityId, date)
- Limit query results (pagination: 100 per page max)
- Cache frequently accessed data (Redis)
- Batch Mercury API requests (avoid rate limits)

### Database
- Time-series data optimized (Balance table partitioning in future)
- Indexes: `entityId`, `accountId`, `date`, `createdAt`
- Query optimization (use Prisma query analysis)

---

## Scalability Path

**Current Capacity (MVP):**
- 6 entities, 30 accounts
- 100 users (mostly David)
- 10K transactions/month

**Future Scaling (Post-Launch):**
- Add Redis caching (handle 100+ concurrent users)
- Database read replicas (separate read/write)
- Worker parallelization (sync entities concurrently)
- CDN for static assets (Cloudflare)
- Horizontal scaling (multiple API instances on Railway)

---

## Diagrams

### Component Diagram

```
┌─────────────────────────────────────────────────────────┐
│                     Browser (User)                       │
└─────────────┬───────────────────────────────────────────┘
              │
      ┌───────▼────────┐
      │  Next.js App   │  (apps/web)
      │  (Frontend)    │
      │                │
      │  - Server      │  ← Prisma Client
      │    Components  │  ─────────┐
      │  - Client      │           │
      │    Components  │           │
      └───────┬────────┘           │
              │                    │
       fetch  │                    │
        /api  │                    │
              │                    │
      ┌───────▼────────┐           │
      │  Express API   │           │
      │  (Backend)     │           │
      │                │           │
      │  - Routes      │           │
      │  - Services    │  ← Prisma │
      │  - Middleware  │  ─────────┤
      └───────┬────────┘           │
              │                    │
       Mercury│                    │
        API   │                    │
              │                    │
      ┌───────▼────────┐           │
      │  Mercury Bank  │           │
      │  (External)    │           │
      └────────────────┘           │
                                   │
      ┌────────────────┐           │
      │  Cron Workers  │  ← Prisma │
      │  (Background)  │  ─────────┤
      └───────┬────────┘           │
              │                    │
              └────────────────────┤
                                   │
              ┌────────────────────▼──┐
              │    PostgreSQL DB      │
              │    (Railway)          │
              │                       │
              │  - Entity             │
              │  - Account            │
              │  - Balance (timeseries)│
              │  - Transaction        │
              │  - Goal, Flow, Alert  │
              └───────────────────────┘
```

---

*Architecture documented: 2026-02-02*  
*Update when major patterns change*
